import React, { useState, useEffect, useRef } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { School, Star, Heart, BookOpen, Sparkles, Trophy, Paint, Gift, ArrowUp, ArrowDown, ArrowLeft, ArrowRight } from 'lucide-react';

// ë°°ê²½ìŒì•… ë° íš¨ê³¼ìŒ
import bgm from '/public/audio/bgm.mp3';
import successSound from '/public/audio/success.wav';
import failSound from '/public/audio/fail.wav';
import clickSound from '/public/audio/click.wav';


const GumihoGame = () => {
  const [gameState, setGameState] = useState('start');
  const [character, setCharacter] = useState(() => {
    const saved = localStorage.getItem('gumiho-character');
    return saved ? JSON.parse(saved) : { hairColor: 'orange', eyeColor: 'brown', tailCount: 1 };
  });
  const [badges, setBadges] = useState(() => {
    const saved = localStorage.getItem('gumiho-badges');
    return saved ? JSON.parse(saved) : [];
  });
  const [storyIndex, setStoryIndex] = useState(() => {
    const saved = localStorage.getItem('gumiho-storyIndex');
    return saved ? JSON.parse(saved) : 0;
  });
  const [miniGameActive, setMiniGameActive] = useState(false); // ë¯¸ë‹ˆê²Œì„ í™œì„±í™” ì—¬ë¶€
  const [miniGameResult, setMiniGameResult] = useState(null); // ë¯¸ë‹ˆê²Œì„ ê²°ê³¼
    const bgmRef = useRef(null);
  
  const playSound = (sound) => {
    if(sound) {
      const audio = new Audio(sound);
      audio.play();
    }
  };
  useEffect(() => {
    if (gameState === 'start') {
        bgmRef.current = new Audio(bgm);
        bgmRef.current.loop = true;
        bgmRef.current.play().catch(e => console.warn("ìŒì•… ìë™ ì¬ìƒ ì‹¤íŒ¨:", e));
      } else {
          if(bgmRef.current) {
              bgmRef.current.pause();
              bgmRef.current.currentTime = 0;
          }
        }

        return () => {
           if(bgmRef.current) {
              bgmRef.current.pause();
              bgmRef.current.currentTime = 0;
            }
        };
  }, [gameState]);

    useEffect(() => {
        localStorage.setItem('gumiho-character', JSON.stringify(character));
    }, [character]);
  
  useEffect(() => {
    localStorage.setItem('gumiho-badges', JSON.stringify(badges));
  }, [badges]);
  
  useEffect(() => {
    localStorage.setItem('gumiho-storyIndex', JSON.stringify(storyIndex));
  }, [storyIndex]);

  const stories = [
      {
        text: "í•™êµì— ë„ì°©í•˜ë‹ˆ ì´ìƒí•œ ë¶„ìœ„ê¸°ê°€ ê°ëŒì•˜ë‹¤. ë‚¯ì„  ì¹œêµ¬ë“¤ì´ ë³´ì˜€ëŠ”ë°... ì–´ë–»ê²Œ í• ê¹Œ?",
        options: [
            { text: "ì¸ì‚¬í•˜ê¸°", next: 1, success: false },
            { text: "ìˆ¨ì–´ì„œ ê´€ì°°í•˜ê¸°", next: 2, success: false },
            { text: "í•™êµ ë°–ìœ¼ë¡œ ë‚˜ê°€ê¸°", next: 3, success: false }
        ],
      },
      {
        text: "ì¸ì‚¬ë¥¼ ê±´ë„¤ë‹ˆ ì¹œêµ¬ë“¤ì´ ë°˜ê°‘ê²Œ ë§ì•„ì£¼ì—ˆë‹¤! ì¹œêµ¬ë“¤ê³¼ ì¦ê±°ìš´ ì‹œê°„ì„ ë³´ë‚´ëŠ”ë°, ê°‘ìê¸° ë§ˆë²• ëŒ€íšŒê°€ ì‹œì‘ëœë‹¤!",
         options: [
            { text: "ë§ˆë²• ëŒ€íšŒ ì°¸ê°€í•˜ê¸°", next: 4, success: false },
            { text: "êµ¬ê²½í•˜ê¸°", next: 5, success: false },
             {text: "ëŒ€íšŒì¥ì„ ëª°ë˜ ë¹ ì ¸ë‚˜ê°€ê¸°", next: 6, success: false }
        ]
      },
       {
        text: "ìˆ¨ì–´ì„œ ê´€ì°°í•˜ë‹ˆ, ì´ìƒí•œ ë§ˆë²•ì‚¬ë“¤ì´ ìˆ˜ìƒí•œ ì£¼ë¬¸ì„ ì™¸ìš°ê³  ìˆì—ˆë‹¤. ì–´ë–»ê²Œ í• ê¹Œ?",
         options: [
            { text: "ë§ˆë²•ì‚¬ë“¤ì—ê²Œ ë‹¤ê°€ê°€ê¸°", next: 7, success: false },
            { text: "ë„ë§ê°€ê¸°", next: 8, success: false },
             {text: "í•¨ê»˜ ì£¼ë¬¸ ì™¸ìš°ê¸°", next: 9, success: false }
        ]
      },
      {
        text: "í•™êµ ë°–ìœ¼ë¡œ ë‚˜ê°€ë‹ˆ, ë†€ë¼ìš´ ê´‘ê²½ì´ í¼ì³ì¡Œë‹¤. ì „ì„¤ ì†ì˜ ë™ë¬¼ë“¤ì´ ì‚´ê³  ìˆëŠ” ìˆ²ì´ì—ˆë‹¤. ì–´ë””ë¡œ ê°ˆê¹Œ?",
         options: [
            { text: "ìˆ² ì† ê¹Šì€ ê³³ìœ¼ë¡œ ê°€ê¸°", next: 10, success: false },
            { text: "ìˆ² ì…êµ¬ì—ì„œ ë¨¸ë¬´ë¥´ê¸°", next: 11, success: false },
             {text: "ë‹¤ì‹œ í•™êµë¡œ ëŒì•„ê°€ê¸°", next: 1, success: false }
        ]
      },
      // ë§ˆë²•ëŒ€íšŒ ì°¸ê°€
      {
        text: "ë§ˆë²• ëŒ€íšŒì—ì„œ ìš°ìŠ¹í–ˆë‹¤! ëª¨ë‘ê°€ ë‚˜ë¥¼ ì¹­ì°¬í•˜ê³ , í•™êµì—ì„œ ì¸ì •ë°›ëŠ” êµ¬ë¯¸í˜¸ê°€ ë˜ì—ˆë‹¤.",
        ending: "ë§ˆë²• ëŒ€íšŒ ìš°ìŠ¹",
        options: [],
          badgeColor:"text-yellow-500"
      },
      // êµ¬ê²½í•˜ê¸°
      {
        text: "ëŒ€íšŒë¥¼ êµ¬ê²½í•˜ë©´ì„œ, ë‹¤ë¥¸ êµ¬ë¯¸í˜¸ë“¤ì´ ë§ˆë²•ì„ ì‚¬ìš©í•˜ëŠ” ëª¨ìŠµì— ê°íƒ„í–ˆë‹¤. ë‚˜ë„ ì—´ì‹¬íˆ ë…¸ë ¥í•´ì•¼ì§€.",
        ending: "í‰ë²”í•œ êµ¬ë¯¸í˜¸ í•™ìƒ",
        options: [],
          badgeColor:"text-gray-500"
      },
       // ëŒ€íšŒì¥ ëª°ë˜ ë¹ ì ¸ë‚˜ê°€ê¸°
      {
        text: "ëŒ€íšŒì¥ì„ ë¹ ì ¸ë‚˜ì™€ ë„ì„œê´€ì— ë„ì°©í–ˆë‹¤. ì±…ì„ ì½ë‹¤ê°€ ë„ì„œê´€ ì§€ê¸° ê²¬ìŠµìƒì´ ë˜ì—ˆë‹¤.",
        ending: "ë„ì„œê´€ ì§€ê¸° ê²¬ìŠµìƒ",
        options: [],
           badgeColor:"text-blue-500"
      },
       // ë§ˆë²•ì‚¬ì—ê²Œ ë‹¤ê°€ê°€ê¸°
      {
        text: "ë§ˆë²•ì‚¬ë“¤ì—ê²Œ ë‹¤ê°€ê°€ë‹ˆ, ê·¸ë“¤ì€ ì¹œì ˆí•˜ê²Œ ë§ˆë²•ì„ ê°€ë¥´ì³ì£¼ì—ˆë‹¤. ë‚˜ì¤‘ì— ë§ˆë²•ì‚¬ì˜ ì¡°ìˆ˜ê°€ ë˜ì—ˆë‹¤.",
         ending: "ë§ˆë²•ì‚¬ì˜ ì¡°ìˆ˜",
         options: [],
         badgeColor:"text-indigo-500"
      },
      // ë„ë§ê°€ê¸°
      {
        text: "ë§ˆë²•ì‚¬ë“¤ì—ê²Œì„œ ë„ë§ì³ í•™êµì— ëŒì•„ì™”ë‹¤. í‰ë²”í•œ í•™ìƒìœ¼ë¡œ ë‚¨ê¸°ë¡œ í–ˆë‹¤.",
        ending: "í‰ë²”í•œ êµ¬ë¯¸í˜¸ í•™ìƒ",
        options: [],
           badgeColor:"text-gray-500"
      },
      // í•¨ê»˜ ì£¼ë¬¸ ì™¸ìš°ê¸°
      {
        text: "ë§ˆë²•ì‚¬ë“¤ê³¼ í•¨ê»˜ ì£¼ë¬¸ì„ ì™¸ìš°ë‹¤ê°€, íŠ¹ë³„í•œ ë§ˆë²•ì„ ë°œê²¬í–ˆë‹¤! ë¹„ë°€ ë§ˆë²•ì„ ë°œê²¬í•œ êµ¬ë¯¸í˜¸ë¡œ ìœ ëª…í•´ì¡Œë‹¤.",
        ending: "ë¹„ë°€ ë§ˆë²• ë°œê²¬",
        options: [],
           badgeColor:"text-purple-500"
      },
       // ìˆ² ê¹Šì€ ê³³
       {
          text:"ìˆ² ì† ê¹Šì€ ê³³ì—ì„œ ì „ì„¤ì˜ ë™ë¬¼ì„ ë§Œë‚¬ë‹¤. ìˆ²ì˜ ìˆ˜í˜¸ìì—ê²Œ ì„ íƒë°›ì•„ ìˆ²ì„ ì§€í‚¤ê²Œ ë˜ì—ˆë‹¤.",
          ending: "ì „ì„¤ì˜ ìˆ˜í˜¸ì",
          options: [],
            badgeColor:"text-green-500"
       },
       // ìˆ² ì…êµ¬
      {
        text: "ìˆ² ì…êµ¬ì—ì„œ ì•„ë¦„ë‹¤ìš´ í’ê²½ì„ ê°ìƒí•˜ê³  í•™êµë¡œ ëŒì•„ì™”ë‹¤. í‰ë²”í•œ í•™êµ ìƒí™œì„ í•˜ê¸°ë¡œ í–ˆë‹¤.",
         ending: "í‰ë²”í•œ êµ¬ë¯¸í˜¸ í•™ìƒ",
         options: [],
           badgeColor:"text-gray-500"
      },
      // í•™ìƒíšŒì¥
       {
        text: "í•™êµë¥¼ ìœ„í•´ ë…¸ë ¥í•œ ê²°ê³¼, í•™ìƒíšŒì¥ì´ ë˜ì—ˆë‹¤! í•™êµë¥¼ ëŒ€í‘œí•˜ëŠ” êµ¬ë¯¸í˜¸ê°€ ë˜ì—ˆë‹¤.",
        ending: "êµ¬ë¯¸í˜¸ í•™êµ í•™ìƒíšŒì¥",
         options: [],
         badgeColor:"text-red-500"
      }
  ];

    const handleChoice = (nextIndex, success) => {
        playSound(clickSound);
        if (success) {
          setMiniGameActive(true); // ì„±ê³µí•˜ë©´ ë¯¸ë‹ˆê²Œì„ ì‹œì‘
            setMiniGameResult(null)
        } else {
            if(stories[nextIndex].ending) {
                const newBadge = {
                    title: stories[nextIndex].ending,
                    color: stories[nextIndex].badgeColor,
                }
               setBadges(prevBadges => {
                 const hasBadge = prevBadges.some(badge => badge.title === newBadge.title);
                 return hasBadge ? prevBadges : [...prevBadges, newBadge];
               });
                
                setGameState('start')
               setStoryIndex(0)
            }else {
                setStoryIndex(nextIndex);
            }
            
          }
        
    };

  const StartScreen = () => (
    <div className="min-h-screen bg-gradient-to-br from-orange-100 to-pink-100 p-6">
      <div className="animate-bounce text-4xl font-bold text-center text-orange-600 mb-8">
        ğŸ¦Š êµ¬ë¯¸í˜¸ë¥¼ ì°¾ì•„ë¼! ğŸ¦Š
      </div>
      
      <Card className="max-w-2xl mx-auto bg-white/80 backdrop-blur">
        <CardContent className="p-6">
          <div className="grid grid-cols-3 gap-4 mb-8">
            {badges.map((badge, i) => (
              <div key={i} className="flex items-center justify-center p-4 bg-orange-50 rounded-lg">
                <Trophy className={`w-8 h-8 ${badge.color}`} />
              </div>
            ))}
          </div>
          
          <div className="space-y-4">
            <Button
              onClick={() => {
                  playSound(clickSound);
                  setGameState('customize')
              }}
              className="w-full py-6 text-xl bg-gradient-to-r from-orange-500 to-pink-500 hover:from-orange-600 hover:to-pink-600 group"
            >
              <span className="group-hover:scale-110 transition-transform inline-block">
                ìƒˆ ê²Œì„ ì‹œì‘í•˜ê¸°
              </span>
            </Button>
            
            <Button
              onClick={() => {
                  playSound(clickSound);
                  setGameState('game');
              }}
              className="w-full py-6 text-xl bg-gradient-to-r from-purple-500 to-blue-500 hover:from-purple-600 hover:to-blue-600"
              disabled={badges.length === 0}
            >
              ì´ì–´í•˜ê¸°
            </Button>
          </div>
        </CardContent>
      </Card>

      <div className="fixed bottom-4 right-4 animate-pulse">
        <div className="bg-white/90 p-3 rounded-full shadow-lg">
          <Gift className="w-6 h-6 text-pink-500" />
        </div>
        <div className="text-sm mt-2 text-center">
          ë°œê²¬í•œ ì—”ë”©: {badges.length}/9
        </div>
      </div>
    </div>
  );

  const CustomizeCharacter = () => (
    <div className="p-6 bg-gradient-to-br from-purple-100 to-blue-100">
      <Card className="max-w-2xl mx-auto">
        <CardContent className="p-6">
          <h2 className="text-2xl font-bold text-center mb-6">ë‚˜ë§Œì˜ êµ¬ë¯¸í˜¸ ë§Œë“¤ê¸°</h2>
          
          <div className="space-y-6">
            <div className="flex items-center justify-center gap-4">
              {['orange', 'brown', 'silver'].map(color => (
                <button
                  key={color}
                  onClick={() => {
                      playSound(clickSound);
                      setCharacter(c => ({...c, hairColor: color}))
                  }}
                  className={`w-12 h-12 rounded-full transition-transform hover:scale-110
                    ${character.hairColor === color ? 'ring-4 ring-blue-500' : ''}
                    bg-${color}-500`}
                />
              ))}
            </div>

            <div className="flex justify-center gap-4">
              {[1, 3, 9].map(count => (
                <button
                  key={count}
                  onClick={() => {
                      playSound(clickSound);
                      setCharacter(c => ({...c, tailCount: count}))
                  }}
                  className={`p-4 rounded-lg transition-all
                    ${character.tailCount === count ? 'bg-orange-500 text-white' : 'bg-orange-100'}
                    hover:bg-orange-400`}
                >
                  ê¼¬ë¦¬ {count}ê°œ
                </button>
              ))}
            </div>

            <Button
              onClick={() => {
                  playSound(clickSound);
                  setGameState('game');
              }}
              className="w-full py-4 text-lg bg-gradient-to-r from-orange-500 to-pink-500"
            >
              ì™„ì„±!
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );

    const GameScreen = () => {
      const currentStory = stories[storyIndex];

      return (
      <div className="min-h-screen bg-gradient-to-br from-green-100 to-yellow-100 p-6">
          <Card className="max-w-2xl mx-auto bg-white/80 backdrop-blur">
        <CardContent className="p-6">
             <h2 className="text-2xl font-bold text-center mb-6">ì´ì•¼ê¸°</h2>
            <p className="text-lg mb-6">{currentStory.text}</p>
            {currentStory.options && (
              <div className="space-y-4">
                {currentStory.options.map((option, index) => (
                  <Button
                    key={index}
                    onClick={() => handleChoice(option.next, option.success)}
                    className="w-full py-4 text-lg bg-gradient-to-r from-green-500 to-yellow-500 hover:from-green-600 hover:to-yellow-600 group"
                   >
                       <span className="group-hover:scale-110 transition-transform inline-block">
                          {option.text}
                        </span>
                   </Button>
                ))}
              </div>
            )}
                </CardContent>
          </Card>
      </div>
      );
    };


    const MiniGame = () => {
        const [keysPressed, setKeysPressed] = useState([]);
        const [sequence, setSequence] = useState(generateSequence());
      const [gameMessage, setGameMessage] = useState(null);
      
      const arrowClasses = {
           ArrowUp:"text-blue-500 animate-bounce",
           ArrowDown:"text-red-500 animate-bounce",
           ArrowLeft:"text-green-500 animate-bounce",
           ArrowRight:"text-purple-500 animate-bounce"
      }
        const generateSequence = () => {
             const arrows = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            return Array.from({ length: 5 }, () => arrows[Math.floor(Math.random() * 4)]);
        }

      const handleKeyDown = (event) => {
            if(event.code.startsWith('Arrow')) {
                setKeysPressed(prevKeys => [...prevKeys, event.code]);
            }
       
      };


      useEffect(() => {
            if (keysPressed.length > 0) {
                const currentKey = keysPressed[keysPressed.length - 1];
               const expectedKey = sequence[keysPressed.length -1];
                if (currentKey !== expectedKey) {
                    setGameMessage("ì‹¤íŒ¨!");
                    playSound(failSound)
                  setTimeout(() => {
                    setMiniGameActive(false);
                    setKeysPressed([])
                     setSequence(generateSequence());
                    setGameMessage(null);
                   
                  }, 1000);
                   return;
                   
                }
            }
            
             if (keysPressed.length === sequence.length) {
                playSound(successSound);
                  setGameMessage("ì„±ê³µ!");
                 setTimeout(() => {
                     setMiniGameResult(true);
                  setMiniGameActive(false);
                    setKeysPressed([])
                    setSequence(generateSequence());
                     setGameMessage(null);
                     const newBadge = {
                         title: "ê¼¬ë¦¬ ì²´ì¡° ì±”í”¼ì–¸",
                         color:"text-pink-500"
                     }
                    setBadges(prevBadges => {
                    const hasBadge = prevBadges.some(badge => badge.title === newBadge.title);
                    return hasBadge ? prevBadges : [...prevBadges, newBadge];
                  });
                 }, 1000);
            }

        }, [keysPressed, sequence]);

       useEffect(() => {
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
       }, [handleKeyDown]);

      return (
      <div className="fixed inset-0 bg-black/50 flex items-center justify-center">
          <Card className="w-96">
            <CardContent className="p-6">
             <h3 className="text-xl font-bold mb-4">ê¼¬ë¦¬ ì²´ì¡° ë¯¸ë‹ˆê²Œì„!</h3>
          <div className="h-48 bg-orange-100 rounded-lg mb-4 flex items-center justify-center">
                <div className="space-y-4">
                 
                  <div className="flex justify-center gap-2">
                  {sequence.slice(0, keysPressed.length).map((item,index) => {
                    const Icon = item === "ArrowUp" ? ArrowUp : item === "ArrowDown" ? ArrowDown : item === "ArrowLeft" ? ArrowLeft : ArrowRight;
                       return (
                        <Icon key={index} className="w-10 h-10 text-gray-500" />
                      )
                    })}
                    
                     {sequence.slice(keysPressed.length).map((item,index) => {
                    const Icon = item === "ArrowUp" ? ArrowUp : item === "ArrowDown" ? ArrowDown : item === "ArrowLeft" ? ArrowLeft : ArrowRight;
                       return (
                        <Icon key={index} className={`w-10 h-10  ${arrowClasses[item]}`} />
                      )
                    })}
                  </div>
                  
                    {gameMessage &&  <p>{gameMessage}</p>}
                  </div>
          </div>
          </CardContent>
        </Card>
        </div>
    )
    };
  return (
    <div>
      {gameState === 'start' && <StartScreen />}
      {gameState === 'customize' && <CustomizeCharacter />}
      {gameState === 'game' && <GameScreen />}
      {miniGameActive && <MiniGame/>}
    </div>
  );
};

export default GumihoGame;
